{% extends "base.html" %}
{% block content %}
<h2>Basic Mode</h2>
<div class="box">
  <div style="margin-bottom:1em;">
    <button id="fix-all-btn" title="Run all fixes">Fix All</button>
    <div class="progress-container" id="fix-all-progress-container" style="display:none;">
      <div class="progress-bar" id="fix-all-progress-bar"></div>
    </div>
    <div class="progress-label" id="fix-all-progress-label"></div>
  </div>
  
  <div style="margin-bottom:1em;">
    <button id="fix-myanonamouse-btn" title="Fix MyAnonamouse">Fix MyAnonamouse</button>
    <div class="progress-container" id="fix-mam-progress-container" style="display:none;">
      <div class="progress-bar" id="fix-mam-progress-bar"></div>
    </div>
    <div class="progress-label" id="fix-mam-progress-label"></div>
  </div>
  
  <div style="margin-bottom:1em;">
    <button id="fix-prowlarr-btn" title="Fix Prowlarr">Fix Prowlarr</button>
    <div class="progress-container" id="fix-prowlarr-progress-container" style="display:none;">
      <div class="progress-bar" id="fix-prowlarr-progress-bar"></div>
    </div>
    <div class="progress-label" id="fix-prowlarr-progress-label"></div>
  </div>
  
  <div id="status-message" style="margin-top:1em;font-weight:600;"></div>
  <div id="progress-log" class="progress-log" style="display:none;"></div>
</div>

<div class="box">
  <h3>Automated Timer</h3>
  <p style="margin-bottom:1em;color:#666;line-height:1.5;">
    The automated timer runs "Fix All" on a schedule to keep your MAM cookies fresh and sessions active. 
    Configure the schedule in the Config page (run time, interval, and jitter). 
    When enabled, it will automatically renew your MyAnonamouse sessions for qBittorrent and Prowlarr.
  </p>
  <div style="margin-bottom:1em;">
    <label for="timer-toggle" style="font-weight:600;margin-right:1em;">Timer Status:</label>
    <button id="timer-toggle" style="padding:0.5em 1em;font-weight:bold;" title="Click to start/stop automated timer">TIMER OFF</button>
  </div>
  <div class="auto-start-section" style="margin-bottom:1em;padding:0.8em;border:1px solid #b3d9ff;border-radius:4px;">
    <label style="display:flex;align-items:center;cursor:pointer;">
      <input type="checkbox" id="auto-start-toggle" style="margin-right:0.5em;width:18px;height:18px;cursor:pointer;">
      <span style="font-weight:600;">Auto-start timer on container restart</span>
    </label>
    <small style="display:block;margin-top:0.5em;line-height:1.4;">
      When enabled, the timer will automatically resume when the container restarts or is updated. 
      This ensures your scheduled tasks continue running even after maintenance or updates. 
      The timer will restart with its previously scheduled next run time.
    </small>
  </div>
  <div id="timer-info" style="margin-top:1em;">
    <div style="margin-bottom:0.5em;"><strong>Current Server Time:</strong> <span id="current-server-time" style="color:#0066cc;">Loading...</span></div>
    <div style="margin-bottom:0.5em;"><strong>Next Run:</strong> <span id="next-run-time">Not scheduled</span></div>
    <div style="margin-bottom:0.5em;"><strong>Last Run:</strong> <span id="last-run-time">Never</span></div>
  </div>
  <div style="margin-top:1.5em;">
    <h4>Run History (Last 10 runs):</h4>
    <div id="run-history" class="run-history-box" style="font-size:0.9em;padding:0.5em;border-radius:4px;max-height:200px;overflow-y:auto;">
      <em>No runs yet</em>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const fixAllBtn = document.getElementById('fix-all-btn');
  const fixMamBtn = document.getElementById('fix-myanonamouse-btn');
  const fixProwlarrBtn = document.getElementById('fix-prowlarr-btn');
  const timerToggleBtn = document.getElementById('timer-toggle');
  const autoStartToggle = document.getElementById('auto-start-toggle');
  const statusMessage = document.getElementById('status-message');
  const progressLog = document.getElementById('progress-log');
  const nextRunTime = document.getElementById('next-run-time');
  const lastRunTime = document.getElementById('last-run-time');
  const runHistory = document.getElementById('run-history');
  const currentServerTime = document.getElementById('current-server-time');
  
  let timerActive = false;
  let statusCheckInterval = null;
  
  // Update current server time every second
  function updateCurrentTime() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    const timeString = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    currentServerTime.textContent = timeString;
  }
  
  // Update time immediately and then every second
  updateCurrentTime();
  setInterval(updateCurrentTime, 1000);
  
  // Helper function to update status display
  function updateStatus(message, isError = false) {
    statusMessage.innerHTML = isError ? 
      `<span style='color:#bb0000'>✗ ${message}</span>` : 
      `<span style='color:#007700'>✓ ${message}</span>`;
  }
  
  // Helper function to append to progress log
  function appendProgress(message) {
    progressLog.style.display = 'block';
    progressLog.textContent += message + '\n';
    progressLog.scrollTop = progressLog.scrollHeight;
  }
  
  // Helper function to clear progress log
  function clearProgress() {
    progressLog.textContent = '';
    progressLog.style.display = 'none';
  }
  
  // Helper functions for progress bars
  function showProgress(barId, containerId, labelId, message) {
    const container = document.getElementById(containerId);
    const bar = document.getElementById(barId);
    const label = document.getElementById(labelId);
    
    if (container) container.style.display = 'block';
    if (bar) {
      bar.style.width = '0%';
      bar.className = 'progress-bar in-progress';
    }
    if (label) {
      label.textContent = message;
      label.className = 'progress-label';
    }
  }
  
  function updateProgress(barId, percentage, message, labelId) {
    const bar = document.getElementById(barId);
    const label = document.getElementById(labelId);
    
    if (bar) bar.style.width = percentage + '%';
    if (label && message) label.textContent = message;
  }
  
  function completeProgress(barId, labelId, success, message) {
    const bar = document.getElementById(barId);
    const label = document.getElementById(labelId);
    
    if (bar) {
      bar.style.width = '100%';
      bar.className = success ? 'progress-bar success' : 'progress-bar error';
    }
    if (label) {
      label.textContent = message;
      label.className = success ? 'progress-label success' : 'progress-label error';
    }
  }
  
  function hideProgress(containerId, labelId) {
    const container = document.getElementById(containerId);
    const label = document.getElementById(labelId);
    
    setTimeout(() => {
      if (container) container.style.display = 'none';
      if (label) label.textContent = '';
    }, 5000);
  }
  
  // Load timer status
  function loadTimerStatus() {
    fetch('/api/timer_status')
      .then(r => r.json())
      .then(data => {
        if (data.active) {
          timerActive = true;
          timerToggleBtn.textContent = 'TIMER ON';
          timerToggleBtn.style.backgroundColor = '#28a745';
          timerToggleBtn.style.color = '#fff';
        } else {
          timerActive = false;
          timerToggleBtn.textContent = 'TIMER OFF';
          timerToggleBtn.style.backgroundColor = '#6c757d';
          timerToggleBtn.style.color = '#fff';
        }
        
        nextRunTime.textContent = data.next_run || 'Not scheduled';
        lastRunTime.textContent = data.last_run || 'Never';
        
        // Update auto-start checkbox
        if (autoStartToggle) {
          autoStartToggle.checked = data.auto_start || false;
        }
        
        // Update run history
        if (data.history && data.history.length > 0) {
          let historyHtml = '';
          data.history.forEach(entry => {
            const statusColor = entry.status === 'Success' ? '#007700' : (entry.status === 'Partial' ? '#ff8800' : '#bb0000');
            historyHtml += `<div style='margin-bottom:0.3em;border-bottom:1px solid #ddd;padding-bottom:0.3em;'>`;
            historyHtml += `<strong>${entry.timestamp}</strong> - <span style='color:${statusColor}'>${entry.status}</span>`;
            if (entry.details) {
              historyHtml += `<br><small>${entry.details}</small>`;
            }
            historyHtml += `</div>`;
          });
          runHistory.innerHTML = historyHtml;
        } else {
          runHistory.innerHTML = '<em>No runs yet</em>';
        }
      })
      .catch(error => {
        console.log('Could not load timer status:', error);
      });
  }
  
  // Load timer status on page load
  loadTimerStatus();
  
  // Refresh timer status every 10 seconds
  setInterval(loadTimerStatus, 10000);
  
  // Fix All button
  if (fixAllBtn) {
    fixAllBtn.addEventListener('click', function() {
      clearProgress();
      showProgress('fix-all-progress-bar', 'fix-all-progress-container', 'fix-all-progress-label', 'Starting Fix All...');
      updateStatus('Running Fix All... This may take a while...');
      fixAllBtn.disabled = true;
      fixMamBtn.disabled = true;
      fixProwlarrBtn.disabled = true;
      
      appendProgress('Starting Fix All operation...');
      updateProgress('fix-all-progress-bar', 10, 'Processing...', 'fix-all-progress-label');
      
      fetch('/api/fix_all', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      }).then(r => r.json()).then(data => {
        fixAllBtn.disabled = false;
        fixMamBtn.disabled = false;
        fixProwlarrBtn.disabled = false;
        
        if (data.success) {
          updateStatus(data.message);
          completeProgress('fix-all-progress-bar', 'fix-all-progress-label', true, '✓ Fix All completed successfully');
        } else {
          updateStatus(data.message, true);
          completeProgress('fix-all-progress-bar', 'fix-all-progress-label', false, '✗ Fix All failed');
        }
        
        if (data.steps && data.steps.length > 0) {
          data.steps.forEach(step => {
            appendProgress(`[${step.status}] ${step.name}: ${step.message}`);
          });
        }
        
        // Hide progress bar after 5 seconds
        hideProgress('fix-all-progress-container', 'fix-all-progress-label');
        
        // Refresh timer status to update history
        loadTimerStatus();
        
        // Reload footer status to show updated push time
        if (typeof loadFooterStatus === 'function') {
          loadFooterStatus();
        }
      }).catch(error => {
        fixAllBtn.disabled = false;
        fixMamBtn.disabled = false;
        fixProwlarrBtn.disabled = false;
        updateStatus('Network error: ' + error.message, true);
        completeProgress('fix-all-progress-bar', 'fix-all-progress-label', false, '✗ Network error');
        hideProgress('fix-all-progress-container', 'fix-all-progress-label');
      });
    });
  }
  
  // Fix MyAnonamouse button
  if (fixMamBtn) {
    fixMamBtn.addEventListener('click', function() {
      clearProgress();
      showProgress('fix-mam-progress-bar', 'fix-mam-progress-container', 'fix-mam-progress-label', 'Starting Fix MyAnonamouse...');
      updateStatus('Running Fix MyAnonamouse...');
      fixAllBtn.disabled = true;
      fixMamBtn.disabled = true;
      fixProwlarrBtn.disabled = true;
      
      appendProgress('Starting Fix MyAnonamouse operation...');
      updateProgress('fix-mam-progress-bar', 10, 'Processing...', 'fix-mam-progress-label');
      
      fetch('/api/fix_myanonamouse', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      }).then(r => r.json()).then(data => {
        fixAllBtn.disabled = false;
        fixMamBtn.disabled = false;
        fixProwlarrBtn.disabled = false;
        
        if (data.success) {
          updateStatus(data.message);
          completeProgress('fix-mam-progress-bar', 'fix-mam-progress-label', true, '✓ Fix MyAnonamouse completed successfully');
        } else {
          updateStatus(data.message, true);
          completeProgress('fix-mam-progress-bar', 'fix-mam-progress-label', false, '✗ Fix MyAnonamouse failed');
        }
        
        if (data.steps && data.steps.length > 0) {
          data.steps.forEach(step => {
            appendProgress(`[${step.status}] ${step.name}: ${step.message}`);
          });
        }
        
        hideProgress('fix-mam-progress-container', 'fix-mam-progress-label');
        
        // Reload footer status
        if (typeof loadFooterStatus === 'function') {
          loadFooterStatus();
        }
      }).catch(error => {
        fixAllBtn.disabled = false;
        fixMamBtn.disabled = false;
        fixProwlarrBtn.disabled = false;
        updateStatus('Network error: ' + error.message, true);
        completeProgress('fix-mam-progress-bar', 'fix-mam-progress-label', false, '✗ Network error');
        hideProgress('fix-mam-progress-container', 'fix-mam-progress-label');
      });
    });
  }
  
  // Fix Prowlarr button
  if (fixProwlarrBtn) {
    fixProwlarrBtn.addEventListener('click', function() {
      clearProgress();
      showProgress('fix-prowlarr-progress-bar', 'fix-prowlarr-progress-container', 'fix-prowlarr-progress-label', 'Starting Fix Prowlarr...');
      updateStatus('Running Fix Prowlarr...');
      fixAllBtn.disabled = true;
      fixMamBtn.disabled = true;
      fixProwlarrBtn.disabled = true;
      
      appendProgress('Starting Fix Prowlarr operation...');
      updateProgress('fix-prowlarr-progress-bar', 10, 'Processing...', 'fix-prowlarr-progress-label');
      
      fetch('/api/fix_prowlarr', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      }).then(r => r.json()).then(data => {
        fixAllBtn.disabled = false;
        fixMamBtn.disabled = false;
        fixProwlarrBtn.disabled = false;
        
        if (data.success) {
          updateStatus(data.message);
          completeProgress('fix-prowlarr-progress-bar', 'fix-prowlarr-progress-label', true, '✓ Fix Prowlarr completed successfully');
        } else {
          updateStatus(data.message, true);
          completeProgress('fix-prowlarr-progress-bar', 'fix-prowlarr-progress-label', false, '✗ Fix Prowlarr failed');
        }
        
        if (data.steps && data.steps.length > 0) {
          data.steps.forEach(step => {
            appendProgress(`[${step.status}] ${step.name}: ${step.message}`);
          });
        }
        
        hideProgress('fix-prowlarr-progress-container', 'fix-prowlarr-progress-label');
      }).catch(error => {
        fixAllBtn.disabled = false;
        fixMamBtn.disabled = false;
        fixProwlarrBtn.disabled = false;
        updateStatus('Network error: ' + error.message, true);
        completeProgress('fix-prowlarr-progress-bar', 'fix-prowlarr-progress-label', false, '✗ Network error');
        hideProgress('fix-prowlarr-progress-container', 'fix-prowlarr-progress-label');
      });
    });
  }
  
  // Timer toggle button
  if (timerToggleBtn) {
    timerToggleBtn.addEventListener('click', function() {
      const newState = !timerActive;
      
      fetch('/api/timer_toggle', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ active: newState })
      }).then(r => r.json()).then(data => {
        if (data.success) {
          loadTimerStatus();
        } else {
          alert('Failed to toggle timer: ' + data.message);
        }
      }).catch(error => {
        alert('Network error: ' + error.message);
      });
    });
  }
  
  // Auto-start toggle
  if (autoStartToggle) {
    autoStartToggle.addEventListener('change', function() {
      const autoStart = autoStartToggle.checked;
      
      fetch('/api/timer_auto_start', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ auto_start: autoStart })
      }).then(r => r.json()).then(data => {
        if (data.success) {
          // Show brief confirmation
          const prevStatus = statusMessage.textContent;
          updateStatus(data.message);
          setTimeout(() => {
            if (statusMessage.textContent === data.message) {
              statusMessage.textContent = prevStatus;
            }
          }, 3000);
        } else {
          alert('Failed to set auto-start: ' + data.message);
          // Revert checkbox
          autoStartToggle.checked = !autoStart;
        }
      }).catch(error => {
        alert('Network error: ' + error.message);
        // Revert checkbox
        autoStartToggle.checked = !autoStart;
      });
    });
  }
});
</script>
{% endblock %}
